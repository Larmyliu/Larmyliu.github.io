---
title: 答辩整理
date: 2024-06-30 14:47:11
---

### 答辩整理

#### 魔方是如何建模的

- 这里主要使用到是three.js技术，第一步是画外形，虽然外观上看上去是一个大的正方体，但其实是做了26个小正方体拼接而成，期间会记录给一个小正方体的坐标位置，最后加上黑色边框，在浏览器上渲染出来。第二步是操控魔方视角，虽然说魔方已经在浏览器渲染出来了，但是因为无法操控空间视角，只能看到魔方的某一个面，这时候要加上three.js提供的视角控制库，我这里用的是轨道空间库，完成视角空间库的初始化，就可以观察到魔方的每一个面，整体就会出现一个3D的效果。最后一步就是监听鼠标事件，达到转动魔方的效果。

#### 转动魔方是如何实现的

- 首先确定触摸点，通过监听鼠标事件操作就可以获得一个平面2D的XY坐标，然后就是通过一个平面2D坐标映射成为3D坐标的问题，这时需要引用three.js提供的Raycaster，原理就是在点击的位置和相机的位置发送一条射线，被这根射线射中的物体都被记录下来，这样就可以知道在三维空间中鼠标移过了什么物体。接下来确定转动方向，根据xyz正负轴分为六个方向，根据滑动的两点确定转动向量，然后判断转动向量和这六个方向向量夹角最小的方向即为转动方向，之后根据转动向量确定转动平面（比如如果滑动平面的法向量平行于坐标系的X轴且等于X轴正方向的单位向量，那么该滑动平面肯定是魔方的`上平面`）,最后通过RequestAnimationFrame完成动画的渲染

#### 魔方随机旋转是是怎么实现的

首先是用随机数生成一个至少大于20的旋转步数。魔方一共有6个面，每个面都可以顺时针或者逆时针旋转，那么就有12种旋转可能，每一种旋转可能对对应着一个旋转动画函数，那么将这将在这12种旋转可能里得到一个随机旋转序列，那么就根据这个序列去执行相对应的旋转动画函数，完成魔方整体的随机旋转。

#### Kociemba算法

阶段一主要是调整棱块和角块的方向，将中间层的棱块放置到中间层（棱块2^11=2048,角块3^7=2187）

剪枝表，表里面存放的信息是距离目标状态(阶段一)或者还原状态(阶段二)最少还需要多少步。如果这个步数大于了还能走的步数，剪掉回溯。 

其实这个的核心主要体现在他的搜索算法和剪枝上，他主要分为有两个阶段的搜索，第一阶段的主要是调整所有棱块和角块的方向，并将中间层的棱块放置到中间层，阶段一整个魔方状态，当出现第一个能达到目的的状态后，会将这个步数以及状态记录下来，用于阶段二的搜索。因为阶段一已经完成了所有棱块和角块的方向，那么阶段二只需要调增位置即可，最终得到一个能够将魔方完整复原的转动序列

#### 加密

**bcrypt**加密，密文长度60位，密码相同时，生成的密文是不一样的。（因为它自动生成随机盐值）

#### 黑盒测试和白盒测试

黑盒

不考虑内部的逻辑结构和具体运作，依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明要求，检测输出结果是否符合

白盒测试
与黑盒相反，把测试对象看作一个透明的盒子，测试时关注程序内部的逻辑结构及有关信息，检验程序中每条通路是否都能按预定要求进行正确工作

主要区别
主要是关注对象不一样。黑盒测试主要针对的是程序展现给用户的功能，多用于功能测试，白盒测试主要针对的是程序代码逻辑，多用于单元测试。简单来说，黑盒测试最终展示功能，白盒测试后台代码程序